# 3주차
## 1. 객체지향
정량적인 방법으로 객체지향적으로 개발하기 위해서 `객체 지향 생활 체조 원칙`을 준수한다.

(1) 한 메서드에 오직 한 단계의 들여쓰기만 한다.

(2) else 예약어를 쓰지 않는다.

(3) 모든 원시 값과 문자열을 포장한다.

(4) 한 줄에 점을 하나만 찍는다.

(5) 줄여 쓰지 않는다(축약 금지).

(6) 모든 엔티티를 작게 유지한다.

(7) 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.

(8) 일급 컬렉션을 쓴다.

(9) getter/setter/프로퍼티를 쓰지 않는다.

<br>

## 2. 모든 원시 값과 문자열을 포장한다.
INT 값을 파라미터로 받는다면, 해당 값에 대한 유효성 검사가 필요하다.

반면에 INT 를 로 LOTTO 라는 객체로 포장을 하면 LOTTO 객체 생성자에서 유효성 검사를 수행하면 되기 때문에 안전하게 사용할 수 있다.

<br>

## 3. 상속과 조합
### (1) 상속
- 상속은 코드를 재사용하는 강력한 수단이지만 항상 최선은 아니다.
- 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 그 자체가 아니다.
- 상속을 완전히 제거하는 것이 아니라 올바르게 사용하자.

```kotlin
class EncryptedDocument: Document() {
    override fun content(): ByteArray {
        // 문서를 로드해서,
        // 즉시 복호화하고,
        // 복호화한 내용을 반환한다.
    }
}
```

- Document 클래스를 상속받으려면 open 키워드를 붙여야한다. (상속을 하려면 의식적으로 개발해야한다.)
- 반면에 추상클래스로 만들면 open 을 붙이지 않아도 된다. (추상클래스의 특징은 직접적으로 인스턴스화가 되지 않는다.)
- 자바는 상속을 막으려면 의식적으로 개발해야한다.


```kotlin
class LottoNumbers : HashSet<LottoNumber>() {
    var addCount = 0
        private set

    override fun add(lottoNumber: LottoNumber): Boolean {
        addCount++
        return super.add(lottoNumber)
    }

    override fun addAll(c: Collection<LottoNumber>): Boolean {
        addCount += c.size
        return super.addAll(c)
    }
}

```

- addAll() 을 호출할 경우 개발자의 의도와는 다른 결과가 나온다. -> addCount 가 예상한 숫자의 두배가 된다.
- 왜냐하면 HashSet 의 addAll() 을 내부적으로 add() 를 반복 호출하고 add() 는 오버라이드 했기 때문에 구현한 메서드를 호출한다.

![image](https://user-images.githubusercontent.com/60383031/171998837-d694c79d-0ab5-411e-9f8d-9c77d65cf17f.png)

- 이러한 문제점은 addAll() 을 재정의하지 않는 방식으로 해결할 수 있다. 단, 이러한 해결방법은 HashSet 의 addAll() 의 내부구현을 미리 알고 있어야 한다.

<br>

### (2) 조합
- 기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자.
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다.
- 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.

```kotlin
class WinningNumber(
    val lottoNumbers: List<LottoNumber>,
    val bonus: LottoNumber
) : LottoNumbers(lottoNumbers)
```
- winningNumber 는 bonusNumber 라는 속성도 가지고 있기 때문에 LottoNumber 와 `is-a` 관계로 보기 어렵다.
- 이러한 케이스는 조합을 사용한다.


<br>

### (3) 상속은 언제 ??
#### 상속이 적절한 경우
- 클래스의 행동을 확장(extend)하는 것이 아니라 정제(refine)할 때다. 
- 확장이란 새로운 행동을 덧붙여 기존의 행동을 부분적으로 보완하는 것을 의미
- 정제란 부분적으로 불완전한 행동을 완전하게 만드는 것을 의미한다.

#### 객체지향 초기 
- 과거에는 컴퓨팅 성능이 안좋았기 때문에 재사용성이 중요한 요소였다.
- 현대에는 시스템이 방대하고 요규사항의 변화가 잦기 때문에 재사용성 보다는 유연성이 훨씬 더 중요한 개념이 되었다.
- 코틀린에 상속 기능이 있는 것은 자바와의 호환성 때문이라고 볼 수 있다.
- DDD 나 MSA 를 하다보면 데이터 중복을 어느정도 수용하는 것과 비슷한 맥락이다.

<br>

### (4) 코틀린에서의 조합
코틀린은 delegate 패턴을 언어 레벨에서 지원을 한다.

`by` 라는 키워드를 사용하면 해당 패턴을 쉽게 사용할 수 있다.





